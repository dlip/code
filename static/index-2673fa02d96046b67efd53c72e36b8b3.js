// Generated by CoffeeScript 2.3.2
(function() {
  /* eslint-disable */
  var Ball, Block, Blocks, Breakout, Collision, KeyboardInput, MouseInput, Paddle, Screen, Sprite, Timer, Vector;

  Screen = class Screen {
    constructor(elem1, width1, height1) {
      this.elem = elem1;
      this.width = width1;
      this.height = height1;
      this.canvas = this.elem;
      this.ctx = this.canvas.getContext("2d");
      this.ctx.onclick = function() {
        return window.location = this.canvas.toDataURL('image/png');
      };
    }

    clear() {
      this.ctx.clearRect(0, 0, this.width, this.height);
      this.ctx.fillStyle = '#000000';
      this.ctx.fillRect(0, 0, this.width, this.height);
      return this.ctx.fillStyle = '#FFFFFF';
    }

    circle(x, y, r) {
      this.ctx.fillStyle = '#FFFFFF';
      this.ctx.beginPath();
      this.ctx.arc(x, y, r, 0, Math.PI * 2, true);
      this.ctx.closePath();
      return this.ctx.fill();
    }

    rect(x, y, w, h, color) {
      this.ctx.fillStyle = '#000000';
      if (color != null) {
        this.ctx.fillStyle = color;
      }
      this.ctx.beginPath();
      this.ctx.rect(x, y, w, h);
      this.ctx.closePath();
      return this.ctx.fill();
    }

  };

  MouseInput = class MouseInput {
    constructor() {
      this.pos = new Vector(0, 0);
      document.addEventListener("mousemove", (event) => {
        return this.onMouseMove(event);
      });
    }

    onMouseMove(event) {
      this.pos.x = event.pageX;
      return this.pos.y = event.pageY;
    }

  };

  KeyboardInput = class KeyboardInput {
    constructor() {
      this.left = false;
      this.right = false;
      document.addEventListener("keydown", (event) => {
        return this.onKeyDown(event);
      });
      document.addEventListener("keyup", (event) => {
        return this.onKeyUp(event);
      });
    }

    onKeyDown(event) {
      switch (event.keyCode) {
        case 39:
        case 73:
          return this.right = true;
        case 37:
        case 78:
          return this.left = true;
      }
    }

    onKeyUp(event) {
      switch (event.keyCode) {
        case 39:
        case 73:
          return this.right = false;
        case 37:
        case 78:
          return this.left = false;
      }
    }

  };

  Sprite = class Sprite {
    constructor(screen1) {
      this.screen = screen1;
    }

    update(time) {}

    draw() {}

  };

  Vector = class Vector {
    constructor(x1, y1) {
      this.x = x1;
      this.y = y1;
    }

  };

  Block = class Block extends Sprite {
    constructor(screen, x, y, width, height, color1) {
      super(screen);
      this.color = color1;
      this.pos = new Vector(x, y);
      this.size = new Vector(width, height);
      this.destroyed = false;
    }

    draw() {
      if (this.destroyed) {
        return;
      }
      return this.screen.rect(this.pos.x, this.pos.y, this.size.x, this.size.y, this.color);
    }

  };

  Blocks = class Blocks extends Sprite {
    constructor(screen) {
      var i, j, ref, ref1, rowcolors, x, y;
      super(screen);
      this.rows = 5;
      this.cols = 5;
      this.blockWidth = (this.screen.width / this.cols) - 1;
      this.blockHeight = 15;
      this.blockPadding = 1;
      rowcolors = ["#FF1C0A", "#FFFD0A", "#00A308", "#0008DB", "#EB0093"];
      this.blocks = new Array(this.rows);
      for (x = i = 0, ref = this.rows; (0 <= ref ? i < ref : i > ref); x = 0 <= ref ? ++i : --i) {
        this.blocks[x] = new Array(this.cols);
        for (y = j = 0, ref1 = this.cols; (0 <= ref1 ? j < ref1 : j > ref1); y = 0 <= ref1 ? ++j : --j) {
          this.blocks[x][y] = new Block(this.screen, x * (this.blockWidth + this.blockPadding) + this.blockPadding, y * (this.blockHeight + this.blockPadding) + this.blockPadding, this.blockWidth, this.blockHeight, rowcolors[y]);
        }
      }
    }

    draw() {
      var i, ref, results, x, y;
      results = [];
      for (x = i = 0, ref = this.rows; (0 <= ref ? i < ref : i > ref); x = 0 <= ref ? ++i : --i) {
        results.push((function() {
          var j, ref1, results1;
          results1 = [];
          for (y = j = 0, ref1 = this.cols; (0 <= ref1 ? j < ref1 : j > ref1); y = 0 <= ref1 ? ++j : --j) {
            results1.push(this.blocks[x][y].draw());
          }
          return results1;
        }).call(this));
      }
      return results;
    }

  };

  Ball = class Ball extends Sprite {
    constructor(screen, paddle, blocks) {
      super(screen);
      this.paddle = paddle;
      this.blocks = blocks;
      this.size = new Vector(10, 10);
      this.vel = new Vector(0, 190);
      this.reset();
    }

    reset() {
      this.pos = new Vector(this.paddle.pos.x + this.paddle.size.x / 2, this.paddle.pos.y - 190);
      if (this.vel.y < 0) {
        return this.vel.y *= -1;
      }
    }

    isOut() {
      return this.pos.y - this.size.y > this.screen.height;
    }

    update(time) {
      var ballBottom, ballLeft, ballRight, ballTop, block, contact, i, j, multiplier, nextOffset, paddleTop, ref, ref1, x, y;
      nextOffset = new Vector(0, 0);
      nextOffset.x = this.vel.x * time;
      nextOffset.y = this.vel.y * time;
      ballBottom = new Vector(this.pos.x, this.pos.y + this.size.y);
      ballTop = new Vector(this.pos.x, this.pos.y - this.size.y);
      ballLeft = new Vector(this.pos.x - this.size.x, this.pos.y);
      ballRight = new Vector(this.pos.x + this.size.x, this.pos.y);
      //todo check it will be off the screen this frame before updating position

      //check wall collision
      if (ballLeft.x < 0 && this.vel.x < 0) {
        this.vel.x *= -1;
      } else if (ballRight.x > this.screen.width && this.vel.x > 0) {
        this.vel.x *= -1;
      } else if (ballTop.y < 0 && this.vel.y < 0) {
        this.vel.y *= -1;
      }
      //check paddle collision
      paddleTop = this.screen.height - this.paddle.size.y;
      if (ballBottom.y < paddleTop && ballBottom.y + nextOffset.y > paddleTop) {
        //check collides with paddle
        if (this.hasCollidedWithPaddle() && this.vel.y > 0) {
          multiplier = (this.pos.x - (this.paddle.pos.x + this.paddle.size.x / 2)) / (this.paddle.size.x / 2);
          this.vel.x = 150 * multiplier;
          this.vel.y *= -1;
        }
      }
//check blocks collision
      for (x = i = 0, ref = this.blocks.rows; (0 <= ref ? i < ref : i > ref); x = 0 <= ref ? ++i : --i) {
        for (y = j = 0, ref1 = this.blocks.cols; (0 <= ref1 ? j < ref1 : j > ref1); y = 0 <= ref1 ? ++j : --j) {
          block = this.blocks.blocks[x][y];
          if (block.destroyed) {
            continue;
          }
          contact = false;
          if (Collision.pointInRect(ballTop, block.pos, block.size) && this.vel.y < 0) {
            contact = true;
            this.vel.y *= -1;
          }
          if (Collision.pointInRect(ballBottom, block.pos, block.size) && this.vel.y > 0) {
            contact = true;
            this.vel.y *= -1;
          }
          if (Collision.pointInRect(ballLeft, block.pos, block.size) && this.vel.x < 0) {
            contact = true;
            this.vel.x *= -1;
          }
          if (Collision.pointInRect(ballRight, block.pos, block.size) && this.vel.x > 0) {
            contact = true;
            this.vel.x *= -1;
          }
          if (contact) {
            block.destroyed = true;
          }
        }
      }
      this.pos.x += nextOffset.x;
      return this.pos.y += nextOffset.y;
    }

    hasCollidedWithPaddle() {
      if (this.pos.x + this.size.x > this.paddle.pos.x && this.pos.x - this.size.x < this.paddle.pos.x + this.paddle.size.x) {
        return true;
      }
      return false;
    }

    draw() {
      return this.screen.circle(this.pos.x, this.pos.y, 10);
    }

  };

  Collision = class Collision {
    static pointInRect(point, rectPos, rectSize) {
      if (point.x > rectPos.x && point.x < rectPos.x + rectSize.x && point.y > rectPos.y && point.y < rectPos.y + rectSize.y) {
        return true;
      }
      return false;
    }

  };

  Paddle = class Paddle extends Sprite {
    constructor(screen, mouseInput, keyboardInput) {
      super(screen);
      this.mouseInput = mouseInput;
      this.keyboardInput = keyboardInput;
      this.size = new Vector(75, 10);
      this.pos = new Vector((this.screen.width / 2) - (this.size.x / 2), this.screen.height - 10);
      this.lastMousePos = this.mouseInput.pos.x;
      this.color = '#444444';
    }

    update(time) {
      if (this.lastMousePos !== this.mouseInput.pos.x) {
        this.pos.x = this.mouseInput.pos.x - this.size.x / 2;
      }
      if (this.keyboardInput.left === true) {
        this.pos.x -= 600 * time;
      }
      if (this.keyboardInput.right === true) {
        this.pos.x += 600 * time;
      }
      if (this.pos.x < 0) {
        this.pos.x = 0;
      }
      if (this.pos.x + this.size.x > this.screen.width) {
        this.pos.x = this.screen.width - this.size.x;
      }
      return this.lastMousePos = this.mouseInput.pos.x;
    }

    draw() {
      return this.screen.rect(this.pos.x, this.pos.y, this.size.x, this.size.y, this.color);
    }

  };

  Timer = class Timer {
    start() {
      this.startDate = new Date();
      return this.lastDate = new Date();
    }

    advance() {
      var now;
      now = new Date;
      this.diffInMilliseconds = now - this.lastDate;
      this.diff = this.diffInMilliseconds / 1000;
      this.timeInMilliseconds += now - this.startDate;
      this.time = this.timeInMilliseconds / 1000;
      return this.lastDate = new Date();
    }

  };

  Breakout = class Breakout {
    constructor(elem1) {
      var blocks, paddle;
      this.elem = elem1;
      this.paused = false;
      this.screen = new Screen(this.elem, 300, 300);
      this.timer = new Timer;
      this.mouseInput = new MouseInput;
      this.keyboardInput = new KeyboardInput;
      this.sprites = [];
      paddle = new Paddle(this.screen, this.mouseInput, this.keyboardInput);
      this.sprites.push(paddle);
      blocks = new Blocks(this.screen);
      this.sprites.push(blocks);
      this.ball = new Ball(this.screen, paddle, blocks);
      this.sprites.push(this.ball);
    }

    run() {
      this.timer.start();
      return setInterval((() => {
        return this.update();
      }), 1000 / 50); //fps
    }

    update() {
      var i, len, ref, results, sprite;
      this.timer.advance();
      if (this.paused) {
        return;
      }
      if (this.ball.isOut()) {
        this.ball.reset();
      }
      this.screen.clear();
      ref = this.sprites;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        sprite = ref[i];
        sprite.update(this.timer.diff);
        results.push(sprite.draw());
      }
      return results;
    }

  };

  console.error("waiting");

  window.addEventListener("load", function() {
    var breakout, elem;
    console.error("doc loaded");
    elem = document.getElementById("coffeescript-breakout");
    breakout = new Breakout(elem);
    return breakout.run();
  });

}).call(this);
